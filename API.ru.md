## Определения для API
Следующие определения будут полезны для понимания API:

**Функция Регистра** - объект, который содержит информацию о функции и её зависимостях (*других* Функций / Переменных Регистра, от которых она зависит) и её зависящих (*других* Функций Регистра, которые от неё зависят)

**Переменная Регистра** - практически то же, что и Функция Регистра, но без зависимостей и без функции, которая её описывает. Это просто объект, хранящий информацию о её текущем значении и зависящих от неё функций и переменных.

**Регистр** - это просто объект, который содержит одну или несколько Функций и Переменных Регистра.

## API
### Функции / Переменные Регистра
Каждая **Функция** или **Переменная Регистра** (например, `logic.profit` или `logic.revenue` в вышеуказанном примере) содержит следующие функции в её прототипе:

* `.of( deps )`, где `deps` - это массив зависимостей.
    
    Эта функция нужна, чтобы установить **Переменные** и **Функции**, от которых эта **Функция** зависит. Возвращает саму **Функцию Регистра** для удобства.

* `.is( fun )`, где `fun` - это функция, которая описывает то, как будет расчитываться значение в случае, если значение хотя бы одной зависимости изменилось.
    
    Устанавливает функцию и возвращает саму **Функцию Регистра** для удобства.
    * Примечание: когда одна из зависимостей **Функции** изменяет значение, `fun` будет вызвана с параметрами `val1`, ... `valN`, `old_val1`, ... `old_valN`, то есть новые значения её зависимостей, за которыми следуют старые значения её зависимостей. Эти значения идут в таком же порядке, как и её зависимости при создании **Функции** или при изменении зависимостей с помощью `.of( deps )`.

* `.set( value )`, где `value` - это новое значение.
    
    Устанавливает значение. Если произошло изменение значения, это спровоцирует пересчёт зависимых от неё **Функций**. Возвращает саму **Функцию Регистра** для удобства.

* `.get( )` возвращает текущее значение.

### Функция revalue()
**revalue** - это функция для создания, а также добавления новых свойств к **Регистру** (например, регистр `logic` в предыдущем примере). **revalue**, как объект, содержит 2 удобных функции для создания **Функций** и **Переменных Регистра**:

1. `revalue.var( value )`, где `value` - это начальное значение для **Переменной**.
   Инициализирует и возвращает **Переменную Регистра** с установленным начальным значением.

2. `revalue.fun( [dep1[, ... [, depN]]] )`, где `dep1`, ... `depN` - это **Функции** и **Переменные Регистра** в качестве зависимостей.
   Инициализирует и возвращает **Функцию Регистра** с установленными зависимостями.

3. `revalue.isVar( param )`, где `param` - это любой параметр.
   Возвращает true если `param` является **Переменной Регистра**, иначе false.

4. `revalue.isFun( param )`, где `param` - это любой параметр.
   Возвращает true если `param` является **Функцией Регистра**, иначе false.

#### Создание нового регистра
Есть 2 способа создания **Регистра**:

1. Лучший способ, с помощью функции
   * `revalue( defineFunction )`
      * `defineFunction( r )` - это функция, которая будет сразу же вызвана с параметром
         * `r` - это то же самое, что и `revalue` (для удобства)
         * Функция должна вернуть объект, содержащий ново-созданные **Функции** и **Переменные Регистра** для присвоения **Регистру**.

2. Альтернативный способ, с помощью объекта
   * `revalue( defineObject )`
      * `defineObject` - это объект, содержащий информацию о желаемых **Функциях** и **Переменных Регистра**. К примеру,
      ```javascript
      revalue({
          'revenue': 150,
          'cost'   : 100,
          'profit' : {
              dependencies: ['revenue', 'cost'],
              is: function(revenue, cost) {
                  return revenue - cost;
              }
          }
      })
      ```

Лучше всего использовать первый способ, потому что

* Все зависимости будут созданы в правильном порядке. В функции можно будет создать **Функцию Регистра** только тогда, когда её зависимости уже созданы. С другой стороны, если **Регистр** создан с помощью объекта, то нужно удостовериться, что вначале описаны зависимости, а уже потом зависящие.

* Этот способ более гибкий. Он позволяет создать **Функции Регистра** без их добавления в сам **Регистр** (создавать *скрытые* **Функции**).

#### Изменение уже существующего регистра
Также можно изменять уже существующий **Регистр** вместо создания нового, если использовать этот **Регистр** как первый параметр. То есть,

* `revalue( registry, defineFunction )`, или

* `revalue( registry, defineObject )`

И в том и в другом случае, новые **Функции** и **Переменные Регистра** будут добавлены к уже существующему `registry`.

## Лицензия
[Лицензия MIT](https://github.com/guitarino/revalue/blob/master/LICENSE)